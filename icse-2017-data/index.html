<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="The "Dark Side" of Code Refactoring">
    <meta name="author" content="Diego Cedrim">

    <title>The "Dark Side" of Code Refactoring</title>

    <!-- Bootstrap core CSS -->
    <link href="bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="grid.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="bower_components/highlightjs/styles/xcode.css">
	<script src="bower_components/highlightjs/highlight.pack.min.js"></script>
	<script src="bower_components/jquery/dist/jquery.min.js"></script>
	<script src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

	<style type="text/css">
	pre {
		border: none;
		background: #ffffff;
		padding: 0px;
	}
	.col-md-6 {
		background: #ffffff;
		border: none;
		padding-bottom: 0px;
	}
	body { padding-top: 70px; position: relative;}
	</style>

	<script type="text/javascript">
	$(document).ready(function() {
		$('body').scrollspy({ target: '#mainNavBar' })
	});
	</script>
  </head>

  <body>
  	<nav id="mainNavBar" class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">

        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-6">
          <ul class="nav navbar-nav">
            <li><a href="#abstract">Abstract</a></li>
            <li><a href="#examples">Examples</a></li>
            <li><a href="#classification">Classification</a></li>
            <li><a href="#refactored_elements">Refactored Elements</a></li>
            <li><a href="#metrics_analysis">Metrics Analysis</a></li>
            <li><a href="#manual_validation">Validation</a></li>
            <li><a href="#root_floss">Root/Floss</a></li>
            <li><a href="#downloads">Downloads</a></li>
            <li><a href="#thresholds">Rules</a></li>
            <li><a href="#authors">Authors</a></li>
            <li><a href="#references">References</a></li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div>
</nav>


    <div class="container">

      <div class="page-header" id="title">
  <h1>The "Dark Side" of Code Refactoring<br/><small>Revealing Harmful Effects on Structural Quality</small></h1>
</div>
This website contains all data not presented in the paper.

      <h3 class="page-header" id="abstract">Abstract</h3>

      <p class="text-justify">Code smells in a program represent indications of structural quality problems, which can be addressed by software refactoring. There is an explicit assumption that software refactoring improves the structural quality of a program by reducing its density of code smells. However, little has been reported about whether and to what extent developers neglect or end up creating code smells through refactoring. This paper reports a longitudinal study intended to address this gap. We analyze how often commonly-used refactoring types affect the density of 13 types of code smells along the version histories of 23 projects. Our findings are based on the analysis of 29,318 refactorings distributed in 10 different types. Even though more than 80% of the refactorings touched smelly elements, 63.2% did not reduce their occurrences. Surprisingly, only 12.3% of refactorings removed smells, while 24.5% induced the introduction of new ones. More than 95% of such refactoring-induced smells were not removed in successive commits. All these findings suggest that refactorings tend to more frequently introduce long- living smells instead of fully eliminating existing ones. Also, we analyzed which types of refactoring affects specific types of code smells more often. Through this analysis, we were able to identify refactoring-smell pairs which occurred more frequently.</p>

      <h3 class="page-header" id="examples">Motivating Examples</h3>

      <p class="text-justify">Code smells are anomalies in the program structure. A code smell is a surface indication that usually corresponds to a deeper problem in the system. There are different types of code smells documented in the literature <a href="#references">[1]</a>. For instance, lets suppose a single class with several responsibilities. A class with this symptom is hard to read and evolve. This type of smell is known as God Class. Another common anomaly is when a method has many parameters. This code smell is known as Long Parameter List. A method with this symptom is also hard to read and evolve.</p>

      <div class="row">
  <div class="col-md-6"> <div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Figure 1: Person class with God Class code smell</h3>
	  </div>
	  <div class="panel-body" style="text-align: center;">
	    <img src="img/person-a.png" width="40%" alt="Person class with God Class code smell" class="img-rounded">
	  </div>
	</div></div>
  <div class="col-md-6"><div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Figure 2: Class after Extract Class refactoring without God Class</h3>
	  </div>
	  <div class="panel-body" style="text-align: center;">
	   <img src="img/person-b.png" width="90%" alt="Person class after Extract Class refactoring without God Class" class="img-rounded">
	  </div>
	</div></div>

</div>

      <p class="text-justify">The structural quality of a program can be quantified by the occurrences of code smells on it. For instance, Figures 1 and 2 show the Person class in two different forms. In Figure 1, the Person class has at least three attributes representing two loosely-coupled concepts: person and telephone number. This version of Person can be considered a God Class. In order to remove this code smell, the developer can extract part of the class structure it into another class: TelephoneNumber (Figure 2). After this transformation, the program no longer has a God Class and still realize the same functionality. As the program have a code smell in Figure 1, its new internal structure represented in Figure 2 has a better structural quality.</p>

      <p class="text-justify">Projects with low structural quality are hard to read and maintain. Therefore, whenever a code smell is identified in a program, a change should be made to remove it. Refactoring is a structural change intended to remove a code smell without changing its observable behavior <a href="#references">[1]</a>. There are several claims associated with the benefits of software refactoring, which is all implicitly associated with its capability of improving the software structural quality.</p>

      <p class="text-justify">In fact, refactoring is a common practice <a href="#references">[3]</a> intended to improve code quality attributes <a href="#references">[2]</a>. Code smells are widely used for detecting refactoring opportunities <a href="#references">[4]</a>. Existing studies highlight that developers can use refactoring to improve structural quality by eliminating code smells in software <a href="#references">[5]</a> <a href="#references">[6]</a>. Let’s consider the Figures 1 and 2 again to illustrate this scenario. As mentioned before, the module Person in Figure 1 has a God Class code smell. This happened because this class is accumulating responsibilities that should be fulfilled by two classes. In order to address this smell, the Extract Class refactoring should be performed, i.e., a programmer could create a new class and move the relevant fields and methods from the old class into the new one. This refactoring, in this case, would remove the God Class code smell. Since the number of code smells would be reduced, this refactoring would improve the software structural quality.</p>

      <div class="row">
  <div class="col-md-6"> <div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Listing 1: Deserializer method using a temp variable</h3>
	  </div>
	  <div class="panel-body">
	    <pre><code class="java">public Double deserialize(JsonParser j) {
    JsonNode node = j.getCodec().readTree();
    return node.get("x").val();
}</code></pre>
	  </div>
	</div></div>
  <div class="col-md-6"><div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Listing 2: Deserializer method after Inline Temp refactoring</h3>
	  </div>
	  <div class="panel-body">
	    <pre><code class="java">public Double deserialize(JsonParser j) {
    return j.getCodec().readTree().get("x").val();
}</code></pre>
	  </div>
	</div></div>

</div>



      <p class="text-justify">There is a list of refactoring types documented in literature <a href="#references">[1]</a>. Figures 1 and 2 illustrate the Extract Class refactoring type. Another refactoring type is the Inline Temp. In order to use this refactoring, a temporary variable assigned to once with a simple expression must exist. Listing 1 presents a method responsible for deserializing a piece of JSON code into a Java object. This method uses a temporary variable (node) to return the desired value. This variable is used only in the next line of the method. Therefore, a developer could apply the Inline Temp refactoring to get rid of this variable. As result of this refactoring, the node variable disappears and the resulting method only contains one line (Listing 2).</p>




      <p class="text-justify">The aforementioned refactoring application illustrates a scenario where refactoring was not fully successful in improving structural quality. In this case, a new code smell was introduced by the code change being accomplished by the programmer. The code presented in Listing 1 has no code smells, but the resulting code presented in Listing 2 has one. A call to getCodec method is firstly made. After that, three additional method calls are made in the same chain. This is a code smell know as Message Chain. Navigating through method calls this way means the code is coupled to the structure of the navigation. Therefore, any change in the object graph structure would affect this piece of code. In practice, refactoring may not be effective in some cases as this example illustrates. In this way, refactoring may not improve or maintain the structural quality and, worse, it may introduce new code smells. Lets consider again Listings 1 and 2. In this scenario, the Inline Temp refactoring removed an apparently unnecessary temporary variable, but introduced a new code smell on the software. Consequently, this refactoring degraded the program structural quality. This is an example of how refactoring may not be effective.</p>


      <h3 class="page-header" id="classification">Refactoring Classification</h3>

      <p class="text-justify">Both aforementioned examples presented cases where refactorings have had interference on the existence of code smells. Code smells were removed in the first case (Figures 1 and 2). In the second case, a new code smell instance emerged. These scenarios show how refactoring can interfere positively or negatively in the existence of code smells. The application of a refactoring may contribute to the degradation of structural quality (Listings 1 and 2). In this way, we can classify a single refactoring by looking how it changed the existing code smells. In order to show how this can be made, lets formally define it.</p>

      <p class="text-justify">Let S = {s<sub>1</sub>,s<sub>2</sub>,···,s<sub>n</sub>} be the set of software projects to be evaluated. Each software s has a set of versions V(s) = {v1, v2, &hellip; , v<sub>m</sub>}. Each version vi has a set of elements E(v<sub>i</sub>) = {e<sub>1</sub>, e<sub>2</sub>, &hellip;} representing all methods, classes and fields belonging to it. In Figures 1 and 2, the set S = {PhoneBook} is composed just by one software. This software PhoneBook has two versions V(PhoneBook) = {v<sub>a</sub>, v<sub>b</sub>} represented by Figures 1 and 2, respectively. Finally, each version vi<sub>i</sub> has a set of elements E(v<sub>i</sub>) composed by Person and TelephoneNumber classes, methods and fields.</p>

      <p class="text-justify">In order to be able to detect refactorings we must analyze transformations between each subsequent pair of versions. In this way, we assume R is a refactoring detection function where R(v<sub>i</sub>, v<sub>i+1</sub>) = {r<sub>1</sub>(rt<sub>1</sub>; e<sub>1</sub>), &hellip;, r<sub>k</sub>(rt<sub>k</sub>; e<sub>k</sub>)} gives us a set of tuples composed by two elements: the refactoring type (rt) and the set of refactored elements represented by e. So, the function R give us all refactoring activities detected in a pair of software versions. If we apply the R function in the PhoneBook software, the result would be R(v<sub>a</sub>,v<sub>b</sub>) = {r<sub>1</sub>(Extract Class,e')} where e' = {Person, TelephoneNumber}.</p>

      <p class="text-justify">In this work, it is considered as refactored elements all those directly affected by the refactoring. If a refactoring is applied only in a method body, only this method is considered as refactored element. For instance, lets consider a Move Method refactoring. In this refactoring type,
a method m is moved from class A to B. Hence, the considered refactored elements in this case would be {m, A, B}. All m method callers are affected by this refactoring, but we do not consider they as refactored elements. This is a limitation of the tools used. As another example, lets consider the Rename Method refactoring. In this scenario, a new name is given to the method m and the refactored element set would be just {m}. For each refactoring type a different refactored element set is used.</p>

      <p class="text-justify">Let CS be a code smell detection function where CS(e) = {cs<sub>1</sub>,&hellip;} returns a set of code smells present in a software element set e. As the objective is to classify refactorings, the classifying procedure will only analyze code smells related to elements affected by a refactoring. In this way, we can say that CS<sub>b[r]</sub>(e) is the set of code smells of e before the application of the refactoring r. On the other hand, CS<sub>a[r]</sub>(e) is the set of code smells found after the application of r. Considering r<sub>1</sub> refactoring applied on classes of PhoneBook system, CS function would present the following results: CS<sub>b[r<sub>1</sub>]</sub>({Person}) = {God Class} and CS<sub>a[r<sub>1</sub>]</sub>({Person,TelephoneNumber}) = &empty;.</p>

      <p class="text-justify">Using data collected by the functions defined before, it is possible to classify a refactoring by looking how it interferes in existing code smells. Suppose e is a software element set, r is a refactoring activity and |CS<sub>b[r]</sub>(e)|= x. After r refactoring, |CS<sub>a[r]</sub>(e)|= y. Depending on x and y, it is possible to classify r. If x > y, r reduced the number of code smells on e and, because of that, r is a <strong>positive refactoring</strong>. In other way, if x &lt; y, r increased the number of code smells on e and, because of that, r is a <strong>negative refactoring</strong>. When x = y, r is a <strong>neutral refactoring</strong>. This classification is summarized in the following table.</p>

      <table class="table table-striped">
      <thead>
        <tr>
          <th>Condition</th>
          <th>Classification</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td> |CS<sub>b[r]</sub>(e)| > |CS<sub>a[r]</sub>(e)| </td>
          <td> Positive Refactoring </td>
        </tr>
        <tr>
          <td> |CS<sub>b[r]</sub>(e)| &lt; |CS<sub>a[r]</sub>(e)| </td>
          <td> Negative Refactoring </td>
        </tr>
        <tr>
          <td> |CS<sub>b[r]</sub>(e)| = |CS<sub>a[r]</sub>(e)| </td>
          <td> Neutral Refactoring </td>
        </tr>
      </tbody>
    </table>

      <h3 class="page-header" id="refactored_elements">Refactored Elements</h3>


      <p class="text-justify"> In this work, it is considered as refactored elements all those directly affected by the refactoring. If a refactoring is applied only in a method body, only this method is considered as refactored element. For instance, lets consider the Move Method refactoring. In this refactoring type, a method m is moved from class A to B. Hence, the considered refactored elements in this case would be {m, A, B}. All m method callers are affected by this refactoring, but we do not consider them as refactored elements. As another example, let us consider the Rename Method refactoring. In this scenario, a new name is given to the method m and the refactored element set would be just {m}. For each refactoring type a different refactored element set is used. In the following table, we present the considered refactored elements for each type of refactoring. </p>

      <table class="table table-striped">
      <thead>
        <tr>
          <th>Refactoring</th>
          <th>Refactored Elements</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td> Extract Interface </td>
          <td> classes implementing the new interface. </td>
        </tr>
        <tr>
          <td> Extract Method </td>
          <td> (i) method created; (ii) method from where the new method was extracted; and (iii) class containing both methods. </td>
        </tr>
        <tr>
          <td> Extract Superclass </td>
          <td> (i) classes extending the new class; and (ii) new class created.  </td>
        </tr>
        <tr>
          <td> Inline Method </td>
          <td> (i) the method which received the new code; and (ii) class containing the method. </td>
        </tr>
        <tr>
          <td> Move Field </td>
          <td> the two classes affected by the change: the class which the field used to reside and the class which received the field. </td>
        </tr>
        <tr>
          <td> Move Method </td>
          <td> the two classes affected by the change: the class which the method used to reside and the class which received the method. </td>
        </tr>
        <tr>
          <td> Pull Up Field </td>
          <td> the two classes affected by the change: the class which the field used to reside and the class which received the field. </td>
        </tr>
        <tr>
          <td> Pull Up Method </td>
          <td> the two classes affected by the change: the class which the method used to reside and the class which received the method. </td>
        </tr>
        <tr>
          <td> Push Down Field </td>
          <td> the two classes affected by the change: the class which the field used to reside and the class which received the field. </td>
        </tr>
        <tr>
          <td> Push Down Method </td>
          <td> the two classes affected by the change: the class which the method used to reside and the class which received the method. </td>
        </tr>
         <tr>
          <td> Rename Method </td>
          <td> the renamed method and the class that contains it. </td>
        </tr>
      </tbody>
    </table>


      

      <h3 class="page-header" id="metrics_analysis">Quality Metrics Analysis</h3>

       <p class="text-justify">In addition to the impact of refactorings on code smells, we are also interested in measuring their impact on quality metrics. We collected and analyzed a set quality metrics for each version of all projects. We compute the value of each metrics before and after each refactoring operation. The value of each metric can increase, decrease or remain the same. This variation study is used to classify each metric in three cases: (i) improved;
(ii) worsened; or (iii) no effect, depending on the nature of each metric. We used the code smell rules as baseline to define when the metrics values improves or worsens. The following table presents the criteria used to verify whether a metric value improves or not.</p>

      <table class="table table-striped">
  <tr>
    <th>Metric</th>
    <th>Improves when</th>
  </tr>
  <tr>
    <td>Average Number of Lines of Code (AvgLOC)</td>
    <td>Decreases</td>
  </tr>
  <tr>
    <td>Average Number of Lines with Comments (AvgCLOC)</td>
    <td>Decreases</td>
  </tr>
  <tr>
    <td>Base Classes (IFANIN)</td>
    <td>Decreases</td>
  </tr>
  <tr>
    <td>Coupling Between Objects (CBO)</td>
    <td>Decreases</td>
  </tr>
  <tr>
    <td>Number of Children (NOC)</td>
    <td>Increases</td>
  </tr>
  <tr>
    <td>Lines of Code (LOC)</td>
    <td>Decreases</td>
  </tr>
  <tr>
    <td>Lines with Comments (CLOC)</td>
    <td>Increases</td>
  </tr>
  
  <tr>
    <td>Lack of Cohesion in Methods (LOCM)</td>
    <td>Increases</td>
  </tr>
  <tr>
    <td>Number of class methods (CM)</td>
    <td>Increases</td>
  </tr>
  <tr>
    <td>Number of Variables (NV)</td>
    <td>Increases</td>
  </tr>
  <tr>
    <td>Comment to Code Ratio (CCR)</td>
    <td>Decreases</td>
  </tr>
</table>



      <p class="text-justify">We analyzed the effect of each refactoring to the source code metrics (not change/ improve/ worse), grouping by refactoring type. We established a minimum incidence threshold of 85% to conclude that certain refactoring type presents a trend on changing/not changing a specific metric. Taking into account the objective of the refactoring practice we had also established a minimum threshold of 15% to indicate the high incidence of certain refactoring type on worsening a metric.<p>

      <p class="text-justify">Based on these thresholds, we found that all refactoring types tend to do not change the  most of the metrics related to the source code control flow complexity (Average Cyclomatic Complexity, Cyclomatic Complexity, Essential Complexity, Paths). We also found that all refactoring types present high incidence of worsening the amount of line code and/or the amount of line comment, although the ratio of comment to code tends to be preserved in all cases, as can be observed in the following table.<p>

      <table class="table table-striped">
  <tr>
    <th>Metrics</th>
    <th>Move Field</th>
    <th>Move Method</th>
    <th>Pull Up Field</th>
    <th>Pull Up Method</th>
    <th>Push Down Field</th>
    <th>Push Down Method</th>
    <th>Extract Interface</th>
    <th>Inline Method</th>
    <th>Extract Superclass</th>
    <th>Extract Method</th>
  </tr>
  <tr>
    <td>CCR</td>
    <td>0,71%</td>
    <td>7,61%</td>
    <td>4,77%</td>
    <td>2,24%</td>
    <td>3,21%</td>
    <td>4,95%</td>
    <td>9,45%</td>
    <td>3,78%</td>
    <td>7,83%</td>
    <td>5,47%</td>
  </tr>
  <tr>
    <td>AvgCLOC</td>
    <td>3,18%</td>
    <td>13,83%</td>
    <td><strong>20,64%</strong></td>
    <td><strong>16,42%</strong></td>
    <td>8,33%</td>
    <td><strong>17,12%</strong></td>
    <td>8,66%</td>
    <td>11,23%</td>
    <td>9,02%</td>
    <td>7,00%</td>
  </tr>
  <tr>
    <td>AvgLOC</td>
    <td>10,89%</td>
    <td><strong>29,99%</strong></td>
    <td><strong>23,39%</strong></td>
    <td></td>
    <td><strong>19,87%</strong></td>
    <td><strong>31,98%</strong></td>
    <td>9,45%</td>
    <td><strong>29,91%</strong></td>
    <td><strong>25,33%</strong></td>
    <td>6,49%</td>
  </tr>
  <tr>
    <td>LOC</td>
    <td><strong>47,49%</strong></td>
    <td><strong>48,16%</strong></td>
    <td><strong>49,52%</strong></td>
    <td><strong>50,50%</strong></td>
    <td><strong>48,72%</strong></td>
    <td><strong>46,85%</strong></td>
    <td><strong>31,50%</strong></td>
    <td><strong>28,65%</strong></td>
    <td><strong>21,52%</strong></td>
    <td><strong>44,72%</strong></td>
  </tr>
  <tr>
    <td>CLOC</td>
    <td>12,29%</td>
    <td><strong>31,78%</strong></td>
    <td><strong>38,54%</strong></td>
    <td><strong>33,58%</strong></td>
    <td>14,74%</td>
    <td><strong>32,43%</strong></td>
    <td>11,02%</td>
    <td><strong>29,97%</strong></td>
    <td><strong>25,54%</strong></td>
    <td><strong>21,87%</strong></td>
  </tr>
</table>  

      <p class="text-justify">Surprisingly, all refactoring types present a high incidence of worsening one or more of the six object-oriented metrics analyzed. Except by Extract Interface, Extract superclass and Extract method, we found that all other refactoring types present high incidences of worsening both CBO and LOCM (presented in the following table). Almost half of the Inline method refactorings hampers the code cohesion (LOCM). Move field is the single refactoring type that present a high incidence of worsen- ing NV (36.12%), while Extract Interface is the only type that present (great) high incidence of worsening IFANIN (64.17%).<p>

         <table class="table table-striped">
  <tr>
    <th>Metrics</th>
    <th>Move Field</th>
    <th>Move Method</th>
    <th>Pull Up Field</th>
    <th>Pull Up Method</th>
    <th>Push Down Field</th>
    <th>Push Down Method</th>
    <th>Extract Interface</th>
    <th>Inline Method</th>
    <th>Extract Superclass</th>
    <th>Extract Method</th>
  </tr>
  <tr>
    <td>IFANIN</td>
    <td>1,73%</td>
    <td>6,45%</td>
    <td>6,32%</td>
    <td>1,66%</td>
    <td>0,00%</td>
    <td>1,80%</td>
    <td><strong>64,17%</strong></td>
    <td>1,15%</td>
    <td>4,89%</td>
    <td>1,02%</td>
  </tr>
  <tr>
    <td><strong>CBO</strong></td>
    <td>36,01%</td>
    <td><strong>35,04%</strong></td>
    <td><strong>32,34%</strong></td>
    <td><strong>34,91%</strong></td>
    <td><strong>20,51%</strong></td>
    <td><strong>21,62%</strong></td>
    <td>11,42%</td>
    <td><strong>15,19%</strong></td>
    <td>14,13%</td>
    <td><strong>16,06%</strong></td>
  </tr>
  <tr>
    <td>NOC</td>
    <td>0,98%</td>
    <td>4,09%</td>
    <td>2,74%</td>
    <td>3,07%</td>
    <td>0,64%</td>
    <td>1,35%</td>
    <td>3,94%</td>
    <td>0,69%</td>
    <td>1,63%</td>
    <td>0,29%</td>
  </tr>
  <tr>
    <td>CM</td>
    <td>2,47%</td>
    <td>14,99%</td>
    <td>0,36%</td>
    <td>2,40%</td>
    <td>3,85%</td>
    <td>4,50%</td>
    <td>1,18%</td>
    <td>8,08%</td>
    <td>3,80%</td>
    <td>1,50%</td>
  </tr>
  <tr>
    <td><strong>NV</strong></td>
    <td>36,12%</td>
    <td>7,08%</td>
    <td>21,96%</td>
    <td>6,05%</td>
    <td>8,97%</td>
    <td>4,05%</td>
    <td>1,18%</td>
    <td>6,19%</td>
    <td>10,33%</td>
    <td>2,45%</td>
  </tr>
  <tr>
    <td><strong>LOCM</strong></td>
    <td>38,49%</td>
    <td><strong>26,84%</strong></td>
    <td><strong>30,67%</strong></td>
    <td><strong>27,20%</strong></td>
    <td><strong>30,13%</strong></td>
    <td><strong>26,58%</strong></td>
    <td>3,94%</td>
    <td><strong>45,90%</strong></td>
    <td><strong>37,61%</strong></td>
    <td>4,56%</td>
  </tr>
</table>


      <h3 class="page-header" id="manual_validation">Manual Validation</h3>

      <p class="text-justify">The following Table presents the sample sizes of the refactorings manually analyzed by type and the precision obtained to each one. In general, it was observed a high precision for each refactoring type, with a median of 88.36% (excluding rename method). The precision found in all refactoring types are close/inside the standard deviation (7.73). Applying the Grubb outlier test (alpha=0.05) we could not find any outlier, indicating that no refactoring type is strongly influencing the median precision found. Thus, the results found to the representative sample analyzed represent a key factor to provide reliability to the other results reported in this work.<p>

        <table class="table table-striped">
  <tr>
    <th><strong>Ref. type</strong></th>
    <th><strong>pop. size</strong></th>
    <th><strong>sample size</strong></th>
    <th><strong>precision</strong></th>
  </tr>
  <tr>
    <td>Rename method</td>
    <td>12,752</td>
    <td>373</td>
    <td>95.17%</td>
  </tr>
  <tr>
    <td>Extract method</td>
    <td>7,517</td>
    <td>366</td>
    <td>80.60%</td>
  </tr>
  <tr>
    <td>Move field</td>
    <td>4,356</td>
    <td>353</td>
    <td>96.88%</td>
  </tr>
  <tr>
    <td>Inline method</td>
    <td>1,528</td>
    <td>307</td>
    <td>75.57%</td>
  </tr>
  <tr>
    <td>Move method</td>
    <td>1,404</td>
    <td>302</td>
    <td>88.08%</td>
  </tr>
  <tr>
    <td>Pull up method</td>
    <td>629</td>
    <td>239</td>
    <td>78.66%</td>
  </tr>
  <tr>
    <td>Pull up field</td>
    <td>465</td>
    <td>211</td>
    <td>98.58%</td>
  </tr>
  <tr>
    <td>Extract superclass</td>
    <td>342</td>
    <td>181</td>
    <td>93.92%</td>
  </tr>
  <tr>
    <td>Extract interface</td>
    <td>133</td>
    <td>99</td>
    <td>87.88%</td>
  </tr>
  <tr>
    <td>Push down method</td>
    <td>114</td>
    <td>88</td>
    <td>88.64%</td>
  </tr>
  <tr>
    <td>Push down field</td>
    <td>78</td>
    <td>65</td>
    <td>96.92%</td>
  </tr>
</table>


      <h3 class="page-header" id="root_floss">Root Canal Refactoring vs. Floss Refactoring</h3>

      <p class="text-justify">We used Eclipse and the eGit plugin to categorize a transformation (root or floss). We selected a sample containing 730 transformations, and added in our web site. For each transformation in our sample, three authors of the paper manually categorize them. We selected the id commit of the resulting program, and used eGit to find it. By using the diff tool, we manually analyzed all changes in all classes modified in the scope. When a behavioral change was identified, we filled a form explaining it and classified the change as floss. When we did not find a behavioral change, we searched for other refactoring activities and indicated in the form.<p>




      <h3 class="page-header" id="downloads">Downloads</h3>
      <table class="table table-striped">
      <thead>
        <tr>
          <th>#</th>
          <th>Artefact</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="row">1</th>
          <td> <a href="download/projects.xlsx" target="_blank">Projects Analyzed</a></td>
          <td> Name, URL, number of versions and LOC of all analyzed projects. We provide the date and hash of the last commit analyzed </td>
        </tr>
        <!-- <tr>
          <th scope="row">2</th>
          <td> <a href="download/classification-by-project.xlsx" target="_blank">Classification by Project</a></td>
          <td> Refactoring classification grouped by project</td>
        </tr> -->
        <tr>
          <th scope="row">2</th>
          <td> <a href="https://github.com/diegocedrim/RefDetector" target="_blank">Refactoring Miner</a></td>
          <td> Refactoring Miner version used. This is a fork of the original project implemented by <a href="http://users.encs.concordia.ca/~nikolaos/">Nikolaos Tsantalis</a> and <a href="https://github.com/danilofes">Danilo Ferreira e Silva</a></td>
        </tr>
        <tr>
          <th scope="row">3</th>
          <td> <a href="download/ICSE_2017_paper_275_Redacted.pdf" target="_blank">Submited Paper</a></td>
          <td> Complete text submited to ICSE 2017</td>
        </tr>
        <tr>
          <th scope="row">4</th>
          <td> <a href="download/non-removal-patterns.xlsx" target="_blank">Non-Removal Patterns</a></td>
          <td> Complete list of non-removal patterns</td>
        </tr>

      </tbody>
    </table>


    <h3 class="page-header" id="thresholds">Code Smells Rules</h3>
    <p class="text-justify"> <a href="http://www.springer.com/us/book/9783540244295">Lanza et al.</a> originally proposed the rules presented in the following tables. <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6498466&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D6498466">Macia et al.</a> adapted these rules and evaluated the thresholds in another work. Two sets of thresholds were used in order to collect code smells using these rules. The first set, as known as <strong>tight</strong>, represent the thresholds previously validated in the study by <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6498466&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D6498466">Macia et al.</a>. We quality this strategy as tight because it relies on the use of high thresholds values aiming to detect only critical code smells across the projects. The second strategy, named as <strong>relaxed</strong>, uses relaxed thresholds aiming to detect as many code smells as possible. These relaxed thresholds represent lower bound thresholds, which were tuned through our validation phase. These two strategies allowed to derive refactoring classifications based on two different sets of code smells. The following table presents all thresholds used during code smell detection phase.</p>


    <table class="table table-striped">
      <caption>Tight thresholds.</caption>
      <thead>
        <tr>
          <th>#</th>
          <th>Code Smell</th>
          <th>Rule</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="row">1</th>
          <td> Long Method</td>
          <td> (LOC &gt; 50) and (CC &gt; 5)	 </td>
        </tr>
         <tr>
          <th scope="row">2</th>
          <td> Shotgun Surgery</td>
          <td> (CC &gt; 4) and (FanOut &gt; 7) 	 </td>
        </tr>
        <tr>
          <th scope="row">3</th>
          <td> Feature Envy</td>
          <td> (CC &gt; 4) and (FanOut &gt; 4) and (LCOM &lt; 30%) 	 </td>
        </tr>
        <tr>
          <th scope="row">4</th>
          <td> Divergent Change:</td>
          <td> (FanIn &gt; 10) and (LCOM &lt; 50%) and (CC &gt; 4) 	 </td>
        </tr>
        <tr>
          <th scope="row">5</th>
          <td> God Class</td>
          <td> [(LOC &gt; 150) and (CBO &gt; 6)]  or [(NOM &gt; 15) and (CBO &gt; 6)]  </td>
        </tr>
      </tbody>
    </table>

    <table class="table table-striped">
      <caption>Relaxed thresholds.</caption>
      <thead>
        <tr>
          <th>#</th>
          <th>Code Smell</th>
          <th>Rule</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="row">1</th>
          <td> Long Method</td>
          <td> (LOC &gt; 50) and (CC &gt; 3)	 </td>
        </tr>
         <tr>
          <th scope="row">2</th>
          <td> Shotgun Surgery</td>
          <td> (CC &gt; 3) and (FanOut &gt; 4) 	 </td>
        </tr>
        <tr>
          <th scope="row">3</th>
          <td> Feature Envy</td>
          <td> (CC &gt; 3) and (FanOut &gt; 3) and (LCOM &lt; 50%) 	 </td>
        </tr>
        <tr>
          <th scope="row">4</th>
          <td> Divergent Change:</td>
          <td> (FanIn &gt; 5) and (LCOM &lt; 60%) and (CC &gt; 3) 	 </td>
        </tr>
        <tr>
          <th scope="row">5</th>
          <td> God Class</td>
          <td> [(LOC &gt; 150) and (CBO &gt; 6)]  or [(NOM &gt; 15) and (CBO &gt; 6)]  </td>
        </tr>
      </tbody>
    </table>

    <p class="text-justify">As described in the paper, we also used another set of rules to detect code smells. The third set of rules and thresholds was proposed by <a href="http://dl.acm.org/citation.cfm?id=2808301">Bavota et al.</a> The following table presents the rules extracted from this paper.</p>

    <table class="table table-striped">
      <caption>Bavota's Rules</caption>
      <thead>
        <tr>
          <th>#</th>
          <th>Code Smell</th>
          <th>Rule</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="row">1</th>
          <td> Class data should be private</td>
          <td> A class having at least one public field. </td>
        </tr>
        <tr>
          <th scope="row">2</th>
          <td> Complex class</td>
          <td> A class having at least one method for which McCabe cyclomatic complexity is higher than 10. </td>
        </tr>
        <tr>
          <th scope="row">3</th>
          <td> Feature envy</td>
          <td> All methods having more calls with another class than the one they are implemented.</td>
        </tr>
       <tr>
          <th scope="row">4</th>
          <td> God class</td>
          <td> All classes having (i) cohesion lower than the average of the system AND (ii) LOCs > 500.</td>
        </tr>
        <tr>
          <th scope="row">5</th>
          <td> Lazy class</td>
          <td> All classes having LOCs lower than the first quartile of the distribution of LOCs for all system’s classes. </td>
        </tr>
        <tr>
          <th scope="row">6</th>
          <td> Long method</td>
          <td> All methods having LOCs higher than the average of the system. </td>
        </tr>
        <tr>
          <th scope="row">7</th>
          <td> Long parameter list</td>
          <td> All methods having a number of parameters higher than the average of the system. </td>
        </tr>
        <tr>
          <th scope="row">8</th>
          <td> Message chain</td>
          <td> All chains of methods’ calls longer than three. </td>
        </tr>
        <tr>
          <th scope="row">9</th>
          <td> Refused bequest</td>
          <td> All classes overriding more than half of the methods inherited by a superclass. </td>
        </tr>
        <tr>
          <th scope="row">10</th>
          <td> Spaghetti code</td>
          <td> A class implementing at least two long methods (see previous rule) interacting between them through method calls or shared fields.</td>
        </tr>
        <tr>
          <th scope="row">11</th>
          <td> Speculative generality</td>
          <td> A class declared as abstract having less than three children classes using its methods. </td>
        </tr>
      </tbody>
    </table>


    <h3 class="page-header" id="authors">Authors</h3>

    <p>Any question/suggestion please contact the authors of this work.</p>

    <table class="table table-striped">
      <thead>
        <tr>
          <th>#</th>
          <th>Name</th>
          <th>E-mail</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="row">1</th>
          <td>Diego Cedrim</td>
          <td>dcgrego@inf.puc-rio.br</td>
        </tr>
        <tr>
          <th scope="row">2</th>
          <td>Alessandro Garcia</td>
          <td>afgarcia@inf.puc-rio.br</td>
        </tr>
        <tr>
          <th scope="row">3</th>
          <td>Melina Mongiovi</td>
          <td>melina@copin.ufcg.edu.br</td>
        </tr>
        <tr>
          <th scope="row">4</th>
          <td>Rafael de Mello</td>
          <td>rmaiani@inf.puc-rio.br</td>
        </tr>
        <tr>
          <th scope="row">5</th>
          <td>Alexander Chávez</td>
          <td>alopez@inf.puc-rio.br</td>
        </tr>
        <tr>
          <th scope="row">6</th>
          <td>Rohit Gheyi</td>
          <td>rohit@dsc.ufcg.edu.br</td>
        </tr>
        <tr>
          <th scope="row">7</th>
          <td>Baldoino Fonseca</td>
          <td>baldoino@ic.ufal.br</td>
        </tr>
        <tr>
          <th scope="row">8</th>
          <td>Márcio Ribeiro</td>
          <td>marcio@ic.ufal.br</td>
        </tr>
        <tr>
          <th scope="row">9</th>
          <td>Leonardo Sousa</td>
          <td>lsousa@inf.puc-rio.br</td>
        </tr>
        
        
      </tbody>
    </table>

    <h3 class="page-header" id="references" id="references">References</h3>

    <p class="text-justify"><strong>[1]</strong> M. Fowler, K. Beck, J. Brant, W. Opdyke, and D. Roberts, <a target="_blank" href="http://dl.acm.org/citation.cfm?id=311424">Refactoring: Improving the Design of Existing Code</a>, 1 edition. Boston, MA, USA: Addison-Wesley Longman Publishing Co., Inc., 1999.</p>

    <p class="text-justify"><strong>[2]</strong> F. Bourquin and R. K. Keller, <a target="_blank" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=4145033">“High-impact Refactoring Based on Architecture Violations,”</a> in 11th European Conference on Software Maintenance and Reengineering (CSMR’07), 2007, pp. 149–158.</p>

    <p class="text-justify"><strong>[3]</strong> Z. Xing and E. Stroulia, <a target="_blank" href="http://dl.acm.org/citation.cfm?id=1173032">“Refactoring Practice: How it is and How it Should be Supported - An Eclipse Case Study,”</a> in 2006 22nd IEEE International Conference on Software Maintenance, 2006, pp. 458–468.</p>

    <p class="text-justify"><strong>[4]</strong> M. Zhang, T. Hall, and N. Baddoo, <a target="_blank" href="http://dl.acm.org/citation.cfm?id=1967086">“Code Bad Smells: a review of current knowledge,”</a> J. Softw. Maint. Evol. Res. Pract., vol. 23, no. 3, pp. 179–202, Apr. 2011.</p>

    <p class="text-justify"><strong>[5]</strong> R. Kolb, D. Muthig, T. Patzke, and K. Yamauchi, <a target="_blank" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=1510132">“A case study in refactoring a legacy component for reuse in a product line,”</a> in 21st IEEE International Conference on Software Maintenance (ICSM’05), 2005, pp. 369–378.</p>

    <p class="text-justify"><strong>[6]</strong> P. Meananeatra, <a target="_blank" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6494967">“Identifying refactoring sequences for improving software maintainability,”</a> in Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering - ASE 2012, 2012, p. 406.</p>

    </div> <!-- /container -->

    <script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-69581400-1', 'auto');
	  ga('send', 'pageview');

	</script>

  </body>
</html>
